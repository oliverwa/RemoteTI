<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dark Image Analyzer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
      color: #333;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .header {
      text-align: center;
      margin-bottom: 30px;
      border-bottom: 2px solid #eee;
      padding-bottom: 20px;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .control-group label {
      font-weight: 600;
      color: #555;
    }
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    .btn-primary {
      background: #007bff;
      color: white;
    }
    .btn-primary:hover:not(:disabled) {
      background: #0056b3;
    }
    .btn-danger {
      background: #dc3545;
      color: white;
    }
    .btn-danger:hover:not(:disabled) {
      background: #c82333;
    }
    .btn-secondary {
      background: #6c757d;
      color: white;
    }
    .btn-secondary:hover:not(:disabled) {
      background: #545b62;
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .threshold-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .threshold-control input[type="range"] {
      flex: 1;
      min-width: 100px;
    }
    .status-panel {
      background: #e9ecef;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-family: monospace;
      font-size: 13px;
    }
    .analysis-results {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    .folder-list {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      max-height: 500px;
      overflow-y: auto;
    }
    .folder-item {
      padding: 12px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .folder-item:hover {
      background: #f8f9fa;
    }
    .folder-item.selected {
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
    }
    .folder-item.flagged {
      background: #ffebee;
      border-left: 4px solid #f44336;
    }
    .folder-name {
      font-weight: 600;
      margin-bottom: 4px;
    }
    .folder-stats {
      font-size: 12px;
      color: #666;
    }
    .image-preview {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 6px;
      max-height: 500px;
      overflow-y: auto;
    }
    .image-card {
      background: white;
      border-radius: 6px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .image-card img {
      width: 100%;
      height: 150px;
      object-fit: cover;
    }
    .image-info {
      padding: 10px;
      font-size: 12px;
    }
    .image-info.dark {
      background: #ffcdd2;
      color: #c62828;
    }
    .image-info.normal {
      background: #c8e6c9;
      color: #2e7d32;
    }
    .brightness-bar {
      width: 100%;
      height: 6px;
      background: #eee;
      border-radius: 3px;
      margin: 5px 0;
    }
    .brightness-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .stat-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 6px;
      text-align: center;
      border-left: 4px solid #007bff;
    }
    .stat-value {
      font-size: 24px;
      font-weight: 700;
      color: #333;
    }
    .stat-label {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      margin-top: 5px;
    }
    .danger-zone {
      background: #fff5f5;
      border: 2px solid #fed7d7;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #eee;
      border-radius: 4px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #007bff, #0056b3);
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üåô Dark Image Analyzer</h1>
      <p>Analyze drone inspection folders and identify images taken without proper lighting</p>
    </div>

    <!-- Controls -->
    <div class="controls">
      <div class="control-group">
        <label>Brightness Threshold (Optimized)</label>
        <div class="threshold-control">
          <input type="range" id="brightnessThreshold" min="10" max="150" value="100" step="1" disabled style="opacity: 0.5;">
          <span id="thresholdValue">100</span>
        </div>
        <small style="color: #666; margin-top: 4px; display: block;">Fixed at optimal value of 100</small>
        <small>Images below this average brightness are considered "dark"</small>
      </div>

      <div class="control-group">
        <label>Expected Image Count (Fixed)</label>
        <input type="number" id="expectedImageCount" value="8" min="1" max="20" disabled style="opacity: 0.5;">
        <small style="color: #666;">Always exactly 8 images required per session</small>
      </div>

      <div class="control-group">
        <label>Detection Method (Optimized)</label>
        <select id="detectionMethod" disabled style="opacity: 0.5;">
          <option value="average" selected>Average Brightness</option>
          <option value="histogram">Histogram Analysis</option>
          <option value="roi">ROI-Based (Center 50%)</option>
        </select>
        <small style="color: #666; margin-top: 4px; display: block;">Fixed at optimal average brightness method</small>
      </div>

      <div class="control-group">
        <label>Blur Detection Threshold</label>
        <div class="threshold-control">
          <input type="range" id="blurThreshold" min="50" max="300" value="100" step="10">
          <span id="blurThresholdValue">100</span>
        </div>
        <small style="color: #666; margin-top: 4px; display: block;">Lower values = more strict (detect more blurry images). Sharpness below this value flags as blurry.</small>
      </div>

      <div class="control-group">
        <label>Select Hangar</label>
        <select id="hangarSelect" disabled>
          <option value="">Loading hangars...</option>
        </select>
        <button id="scanFolders" class="btn btn-primary" disabled>üìÅ Load Sessions</button>
      </div>

      <div class="control-group">
        <label>Actions</label>
        <button id="analyzeSelected" class="btn btn-secondary" disabled>üîç Analyze Selected</button>
        <button id="exportReport" class="btn btn-secondary" disabled>üìÑ Export Report</button>
      </div>
    </div>

    <!-- Status Panel -->
    <div class="status-panel" id="statusPanel">
      Status: Ready to analyze folders
    </div>

    <!-- Progress Bar -->
    <div class="progress-bar" id="progressContainer" style="display: none;">
      <div class="progress-fill" id="progressFill" style="width: 0%"></div>
    </div>

    <!-- Summary Statistics -->
    <div class="summary-stats" id="summaryStats" style="display: none;">
      <div class="stat-card">
        <div class="stat-value" id="totalFolders">0</div>
        <div class="stat-label">Total Folders</div>
      </div>
      <div class="stat-card" style="border-left-color: #f44336;">
        <div class="stat-value" id="flaggedFolders">0</div>
        <div class="stat-label">Flagged Folders</div>
      </div>
      <div class="stat-card" style="border-left-color: #4caf50;">
        <div class="stat-value" id="goodFolders">0</div>
        <div class="stat-label">Good Folders</div>
      </div>
      <div class="stat-card" style="border-left-color: #ff9800;">
        <div class="stat-value" id="darkImages">0</div>
        <div class="stat-label">Dark Images</div>
      </div>
    </div>

    <!-- Analysis Results -->
    <div class="analysis-results" id="analysisResults" style="display: none;">
      <div>
        <h3>üìÅ Folders</h3>
        <div class="folder-list" id="folderList">
          <!-- Folders will be populated here -->
        </div>
      </div>
      
      <div>
        <h3>üñºÔ∏è Image Preview</h3>
        <div class="image-preview" id="imagePreview">
          <p style="text-align: center; color: #666; grid-column: 1 / -1;">
            Select a folder to preview its images
          </p>
        </div>
      </div>
    </div>

    <!-- Danger Zone -->
    <div class="danger-zone" id="dangerZone" style="display: none;">
      <h3>‚ö†Ô∏è DANGER ZONE: Delete Flagged Session Folders</h3>
      <div style="background: #ffebee; border: 2px solid #f44336; border-radius: 6px; padding: 15px; margin: 15px 0;">
        <p><strong>‚ö†Ô∏è PERMANENT DELETION WARNING:</strong></p>
        <p>This will <strong>permanently delete entire session folders</strong> from your file system:</p>
        <p><code>/Users/oliverwallin/hangar_snapshots/[hangar]/[session_folder]/</code></p>
        <p><strong>All images in flagged folders will be permanently lost!</strong></p>
      </div>
      
      <div id="flaggedFoldersList" style="margin: 15px 0; padding: 10px; background: #fff3e0; border-radius: 4px;">
        <strong>Folders to be deleted:</strong>
        <div id="deletionPreview" style="margin-top: 10px; font-family: monospace; font-size: 12px;">
          No flagged folders
        </div>
      </div>
      
      <div style="margin: 15px 0;">
        <label style="display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="confirmDelete"> 
          <span>I understand this will <strong>PERMANENTLY DELETE</strong> the folders listed above from my hard drive</span>
        </label>
      </div>
      
      <div style="margin: 15px 0;">
        <label style="display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="confirmBackup"> 
          <span>I have backed up any important data I want to keep (STRONGLY RECOMMENDED)</span>
        </label>
      </div>
      
      <div style="margin: 15px 0;">
        <label style="display: flex; align-items: center; gap: 8px;">
          <input type="checkbox" id="confirmUnderstood"> 
          <span>I understand this action CANNOT BE UNDONE and will delete <span id="deleteCount">0</span> folders</span>
        </label>
      </div>
      
      <button id="deleteFlagged" class="btn btn-danger" disabled style="padding: 15px 30px; font-size: 16px;">
        üóëÔ∏è PERMANENTLY DELETE <span id="deleteCount2">0</span> FLAGGED FOLDERS
      </button>
      
      <p style="margin-top: 10px; font-size: 12px; color: #666;">
        Tip: Export a report first to have a record of what was deleted
      </p>
    </div>
  </div>

  <script>
    // State management
    let analysisData = {
      folders: [],
      selectedFolder: null,
      flaggedFolders: new Set(),
      isAnalyzing: false
    };

    // API Configuration
    const API_BASE = 'http://localhost:3002/api';

    // DOM elements
    const elements = {
      brightnessThreshold: document.getElementById('brightnessThreshold'),
      thresholdValue: document.getElementById('thresholdValue'),
      blurThreshold: document.getElementById('blurThreshold'),
      blurThresholdValue: document.getElementById('blurThresholdValue'),
      expectedImageCount: document.getElementById('expectedImageCount'),
      detectionMethod: document.getElementById('detectionMethod'),
      hangarSelect: document.getElementById('hangarSelect'),
      scanFolders: document.getElementById('scanFolders'),
      analyzeSelected: document.getElementById('analyzeSelected'),
      exportReport: document.getElementById('exportReport'),
      statusPanel: document.getElementById('statusPanel'),
      progressContainer: document.getElementById('progressContainer'),
      progressFill: document.getElementById('progressFill'),
      summaryStats: document.getElementById('summaryStats'),
      analysisResults: document.getElementById('analysisResults'),
      folderList: document.getElementById('folderList'),
      imagePreview: document.getElementById('imagePreview'),
      dangerZone: document.getElementById('dangerZone'),
      confirmDelete: document.getElementById('confirmDelete'),
      confirmBackup: document.getElementById('confirmBackup'),
      confirmUnderstood: document.getElementById('confirmUnderstood'),
      deleteFlagged: document.getElementById('deleteFlagged'),
      deleteCount: document.getElementById('deleteCount'),
      deleteCount2: document.getElementById('deleteCount2'),
      deletionPreview: document.getElementById('deletionPreview'),
      totalFolders: document.getElementById('totalFolders'),
      flaggedFolders: document.getElementById('flaggedFolders'),
      goodFolders: document.getElementById('goodFolders'),
      darkImages: document.getElementById('darkImages')
    };

    // Update threshold display
    elements.brightnessThreshold.addEventListener('input', (e) => {
      elements.thresholdValue.textContent = e.target.value;
      if (analysisData.folders.length > 0) {
        reanalyzeWithNewThreshold();
      }
    });

    // Update blur threshold display
    elements.blurThreshold.addEventListener('input', (e) => {
      elements.blurThresholdValue.textContent = e.target.value;
      if (analysisData.folders.length > 0) {
        reanalyzeWithNewThreshold();
      }
    });

    // Update status
    function updateStatus(message) {
      elements.statusPanel.textContent = `Status: ${message}`;
      console.log('Status:', message);
    }

    // Update progress
    function updateProgress(percent) {
      elements.progressFill.style.width = percent + '%';
      if (percent === 0 || percent === 100) {
        elements.progressContainer.style.display = 'none';
      } else {
        elements.progressContainer.style.display = 'block';
      }
    }

    // Calculate image brightness
    function calculateImageBrightness(imageElement, method = 'average') {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = imageElement.naturalWidth;
        canvas.height = imageElement.naturalHeight;
        ctx.drawImage(imageElement, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        let brightness = 0;
        
        switch (method) {
          case 'average':
            let totalBrightness = 0;
            for (let i = 0; i < data.length; i += 4) {
              // Calculate luminance using standard formula
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              totalBrightness += (0.299 * r + 0.587 * g + 0.114 * b);
            }
            brightness = totalBrightness / (data.length / 4);
            break;
            
          case 'histogram':
            const histogram = new Array(256).fill(0);
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const luminance = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
              histogram[luminance]++;
            }
            
            // Calculate percentage of pixels below threshold
            const totalPixels = data.length / 4;
            const darkPixels = histogram.slice(0, 50).reduce((sum, count) => sum + count, 0);
            brightness = 255 * (1 - darkPixels / totalPixels); // Invert so lower = darker
            break;
            
          case 'roi':
            // Analyze center 50% of image
            const startX = Math.floor(canvas.width * 0.25);
            const startY = Math.floor(canvas.height * 0.25);
            const endX = Math.floor(canvas.width * 0.75);
            const endY = Math.floor(canvas.height * 0.75);
            
            let roiBrightness = 0;
            let roiPixels = 0;
            
            for (let y = startY; y < endY; y++) {
              for (let x = startX; x < endX; x++) {
                const index = (y * canvas.width + x) * 4;
                const r = data[index];
                const g = data[index + 1];
                const b = data[index + 2];
                roiBrightness += (0.299 * r + 0.587 * g + 0.114 * b);
                roiPixels++;
              }
            }
            brightness = roiBrightness / roiPixels;
            break;
        }
        
        resolve(Math.round(brightness));
      });
    }

    // Load available hangars
    async function loadHangars() {
      try {
        updateStatus('Loading hangars...');
        const response = await fetch(`${API_BASE}/hangars`);
        const data = await response.json();
        
        if (!response.ok) throw new Error(data.error || 'Failed to load hangars');
        
        elements.hangarSelect.innerHTML = '<option value="">Select a hangar...</option>';
        data.hangars.forEach(hangar => {
          const option = document.createElement('option');
          option.value = hangar;
          option.textContent = hangar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          elements.hangarSelect.appendChild(option);
        });
        
        elements.hangarSelect.disabled = false;
        elements.scanFolders.disabled = false;
        updateStatus(`Found ${data.hangars.length} hangars`);
        
      } catch (error) {
        updateStatus(`Error loading hangars: ${error.message}`);
      }
    }

    // Load sessions for selected hangar
    async function loadSessions() {
      const selectedHangar = elements.hangarSelect.value;
      if (!selectedHangar) {
        updateStatus('Please select a hangar first');
        return;
      }

      try {
        updateStatus('Loading sessions...');
        updateProgress(10);
        
        const response = await fetch(`${API_BASE}/hangars/${selectedHangar}/sessions`);
        const data = await response.json();
        
        if (!response.ok) throw new Error(data.error || 'Failed to load sessions');
        
        updateProgress(100);
        updateStatus(`Found ${data.sessions.length} sessions in ${selectedHangar}`);
        
        // Transform API data to match our expected format
        analysisData.folders = data.sessions.map(session => ({
          name: session.name,
          path: session.path,
          imageCount: session.imageCount,
          hangar: selectedHangar,
          created: session.created,
          modified: session.modified
        }));
        
        displayFolders();
        elements.analyzeSelected.disabled = false;
        updateSummaryStats();
        elements.summaryStats.style.display = 'grid';
        elements.analysisResults.style.display = 'grid';
        
        setTimeout(() => updateProgress(0), 1000);
        
      } catch (error) {
        updateStatus(`Error loading sessions: ${error.message}`);
        updateProgress(0);
      }
    }

    // Load sessions when button clicked
    elements.scanFolders.addEventListener('click', loadSessions);

    // Analyze all sessions
    elements.analyzeSelected.addEventListener('click', async () => {
      if (analysisData.folders.length === 0) {
        alert('Please scan for folders first.');
        return;
      }

      if (analysisData.isAnalyzing) {
        alert('Analysis already in progress. Please wait.');
        return;
      }

      // Analyze ALL folders, not just unanalyzed ones
      await analyzeBatch(analysisData.folders);
    });

    // Display folders in list
    function displayFolders() {
      elements.folderList.innerHTML = '';
      
      analysisData.folders.forEach(folder => {
        const folderElement = document.createElement('div');
        folderElement.className = 'folder-item';
        if (analysisData.flaggedFolders.has(folder.name)) {
          folderElement.classList.add('flagged');
        }
        
        folderElement.innerHTML = `
          <div class="folder-name">${folder.name}</div>
          <div class="folder-stats">
            ${folder.imageCount} images
            ${folder.darkImageCount !== undefined ? `‚Ä¢ ${folder.darkImageCount} dark` : ''}
            ${folder.blurImageCount !== undefined ? `‚Ä¢ ${folder.blurImageCount} blurry` : ''}
            ${folder.avgBrightness !== undefined ? `‚Ä¢ Brightness: ${folder.avgBrightness}` : ''}
            ${folder.avgSharpness !== undefined ? `‚Ä¢ Sharpness: ${folder.avgSharpness}` : ''}
            ${folder.flaggedReasons ? `<br><span style="color: #f44336;">‚ö†Ô∏è ${folder.flaggedReasons.join(', ')}</span>` : ''}
          </div>
        `;
        
        folderElement.addEventListener('click', () => selectFolder(folder));
        elements.folderList.appendChild(folderElement);
      });
    }

    // Select folder for preview
    function selectFolder(folder) {
      // Remove previous selection
      document.querySelectorAll('.folder-item').forEach(item => {
        item.classList.remove('selected');
      });
      
      // Add selection to clicked folder
      event.target.closest('.folder-item').classList.add('selected');
      
      analysisData.selectedFolder = folder;
      displayImagePreview(folder);
    }

    // Analyze session images with real API
    async function analyzeSession(folder) {
      try {
        elements.imagePreview.innerHTML = '<p style="text-align: center; color: #666; grid-column: 1 / -1;">Analyzing images...</p>';
        
        updateStatus(`Analyzing ${folder.name}...`);
        updateProgress(50);
        
        const response = await fetch(`${API_BASE}/analyze-session`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionPath: folder.path,
            method: elements.detectionMethod.value,
            threshold: parseInt(elements.brightnessThreshold.value),
            blurThreshold: parseInt(elements.blurThreshold.value)
          })
        });
        
        const analysisResult = await response.json();
        
        if (!response.ok) throw new Error(analysisResult.error || 'Analysis failed');
        
        // Update folder with analysis results
        folder.images = analysisResult.images.map(img => ({
          name: img.name,
          brightness: img.brightness,
          sharpness: img.sharpness,
          isDark: img.isDark,
          isBlurry: img.isBlurry,
          // Create local file URL for actual images
          url: `http://localhost:3001/api/image/${folder.hangar}/${folder.name}/${img.name}`
        }));
        
        folder.darkImageCount = analysisResult.darkImageCount;
        folder.blurImageCount = analysisResult.blurImageCount;
        folder.avgBrightness = analysisResult.avgBrightness;
        folder.avgSharpness = analysisResult.avgSharpness;
        
        // Check dark images, blur images, AND image count
        const expectedCount = parseInt(elements.expectedImageCount.value);
        const hasIncompleteImages = folder.images.length < expectedCount;
        const hasDarkImages = folder.darkImageCount > 0;
        const hasBlurryImages = folder.blurImageCount > 0;
        
        folder.flagged = hasDarkImages || hasBlurryImages || hasIncompleteImages;
        folder.flaggedReasons = [];
        
        if (hasDarkImages) {
          folder.flaggedReasons.push(`${folder.darkImageCount} dark images`);
        }
        if (hasBlurryImages) {
          folder.flaggedReasons.push(`${folder.blurImageCount} blurry images`);
        }
        if (hasIncompleteImages) {
          folder.flaggedReasons.push(`Only ${folder.images.length}/${expectedCount} images`);
        }
        
        // Update flagged status
        if (folder.flagged) {
          analysisData.flaggedFolders.add(folder.name);
        } else {
          analysisData.flaggedFolders.delete(folder.name);
        }
        
        folder.analyzed = true;
        
        renderImagePreview(folder.images);
        displayFolders(); // Refresh folder list with updated stats
        updateSummaryStats();
        updateDangerZone();
        
        updateProgress(100);
        updateStatus(`Analysis complete: ${folder.darkImageCount}/${folder.images.length} dark images found`);
        setTimeout(() => updateProgress(0), 1000);
        
      } catch (error) {
        updateStatus(`Error analyzing ${folder.name}: ${error.message}`);
        updateProgress(0);
        elements.imagePreview.innerHTML = '<p style="text-align: center; color: #ff0000; grid-column: 1 / -1;">Analysis failed. Check console for details.</p>';
        console.error('Analysis error:', error);
      }
    }

    // Batch analyze multiple sessions
    async function analyzeBatch(folders) {
      analysisData.isAnalyzing = true;
      elements.analyzeSelected.disabled = true;
      elements.analyzeSelected.textContent = 'Analyzing...';

      try {
        updateStatus(`Starting batch analysis of ${folders.length} folders...`);
        let processedCount = 0;
        let flaggedCount = 0;
        
        for (let i = 0; i < folders.length; i++) {
          const folder = folders[i];
          const progress = ((i + 1) / folders.length) * 100;
          
          updateStatus(`Analyzing ${folder.name} (${i + 1}/${folders.length})...`);
          updateProgress(progress);
          
          try {
            // Call API directly for batch processing
            const response = await fetch(`${API_BASE}/analyze-session`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                sessionPath: folder.path,
                method: elements.detectionMethod.value,
                threshold: parseInt(elements.brightnessThreshold.value),
                blurThreshold: parseInt(elements.blurThreshold.value)
              })
            });
            
            const analysisResult = await response.json();
            
            if (!response.ok) throw new Error(analysisResult.error || 'Analysis failed');
            
            // Update folder with analysis results
            folder.images = analysisResult.images.map(img => ({
              name: img.name,
              brightness: img.brightness,
              sharpness: img.sharpness,
              isDark: img.isDark,
              isBlurry: img.isBlurry,
              url: `http://localhost:3001/api/image/${folder.hangar}/${folder.name}/${img.name}`
            }));
            
            folder.darkImageCount = analysisResult.darkImageCount;
            folder.blurImageCount = analysisResult.blurImageCount;
            folder.avgBrightness = analysisResult.avgBrightness;
            folder.avgSharpness = analysisResult.avgSharpness;
            
            // Check dark images, blur images, AND image count
            const expectedCount = parseInt(elements.expectedImageCount.value);
            const hasIncompleteImages = folder.images.length < expectedCount;
            const hasDarkImages = folder.darkImageCount > 0;
            const hasBlurryImages = folder.blurImageCount > 0;
            
            folder.flagged = hasDarkImages || hasBlurryImages || hasIncompleteImages;
            folder.flaggedReasons = [];
            
            if (hasDarkImages) {
              folder.flaggedReasons.push(`${folder.darkImageCount} dark images`);
            }
            if (hasBlurryImages) {
              folder.flaggedReasons.push(`${folder.blurImageCount} blurry images`);
            }
            if (hasIncompleteImages) {
              folder.flaggedReasons.push(`Only ${folder.images.length}/${expectedCount} images`);
            }
            
            // Update flagged status
            if (folder.flagged) {
              analysisData.flaggedFolders.add(folder.name);
              flaggedCount++;
            } else {
              analysisData.flaggedFolders.delete(folder.name);
            }
            
            folder.analyzed = true;
            processedCount++;
            
            // Small delay to prevent overwhelming the API
            await new Promise(resolve => setTimeout(resolve, 50));
            
          } catch (error) {
            console.error(`Failed to analyze ${folder.name}:`, error);
            updateStatus(`Failed to analyze ${folder.name}: ${error.message}`);
          }
        }
        
        // Update UI after batch processing
        displayFolders();
        updateSummaryStats();
        updateDangerZone();
        
        updateStatus(`Batch analysis complete! Processed ${processedCount}/${folders.length} folders. ${flaggedCount} flagged.`);
        setTimeout(() => updateProgress(0), 2000);
        
      } catch (error) {
        console.error('Batch analysis error:', error);
        updateStatus(`Batch analysis failed: ${error.message}`);
        updateProgress(0);
      } finally {
        analysisData.isAnalyzing = false;
        elements.analyzeSelected.disabled = false;
        elements.analyzeSelected.textContent = 'üîç Analyze Selected';
      }
    }

    // Display image preview for selected folder
    function displayImagePreview(folder) {
      if (!folder.images) {
        // Analyze the session if not already done
        analyzeSession(folder);
      } else {
        // Already analyzed, just show the results
        renderImagePreview(folder.images);
      }
    }

    // Render image preview
    function renderImagePreview(images) {
      elements.imagePreview.innerHTML = '';
      
      images.forEach(image => {
        const imageCard = document.createElement('div');
        imageCard.className = 'image-card';
        
        const brightnessPercent = (image.brightness / 255) * 100;
        const brightnessColor = image.isDark ? '#f44336' : '#4caf50';
        
        const sharpnessPercent = Math.min((image.sharpness || 0) / 500, 1) * 100; // Scale sharpness for display
        const sharpnessColor = image.isBlurry ? '#f44336' : '#4caf50';
        
        const hasIssues = image.isDark || image.isBlurry;
        const statusText = hasIssues 
          ? (image.isDark && image.isBlurry ? '‚ö†Ô∏è Dark & Blurry' 
             : image.isDark ? '‚ö†Ô∏è Dark Image' 
             : '‚ö†Ô∏è Blurry Image')
          : '‚úÖ Good Quality';
        
        imageCard.innerHTML = `
          <img src="${image.url}" alt="${image.name}" loading="lazy">
          <div class="image-info ${hasIssues ? 'dark' : 'normal'}">
            <div><strong>${image.name}</strong></div>
            <div>Brightness: ${image.brightness}/255</div>
            <div class="brightness-bar">
              <div class="brightness-fill" style="width: ${brightnessPercent}%; background: ${brightnessColor}"></div>
            </div>
            <div>Sharpness: ${image.sharpness || 0}</div>
            <div class="brightness-bar">
              <div class="brightness-fill" style="width: ${sharpnessPercent}%; background: ${sharpnessColor}"></div>
            </div>
            <div>${statusText}</div>
          </div>
        `;
        
        elements.imagePreview.appendChild(imageCard);
      });
    }

    // Update summary statistics
    function updateSummaryStats() {
      const totalFolders = analysisData.folders.length;
      const flaggedCount = analysisData.flaggedFolders.size;
      const goodCount = totalFolders - flaggedCount;
      const totalDarkImages = analysisData.folders.reduce((sum, folder) => 
        sum + (folder.darkImageCount || 0), 0);
      
      elements.totalFolders.textContent = totalFolders;
      elements.flaggedFolders.textContent = flaggedCount;
      elements.goodFolders.textContent = goodCount;
      elements.darkImages.textContent = totalDarkImages;
    }

    // Update danger zone
    function updateDangerZone() {
      const flaggedCount = analysisData.flaggedFolders.size;
      elements.deleteCount.textContent = flaggedCount;
      elements.deleteCount2.textContent = flaggedCount;
      
      if (flaggedCount > 0) {
        elements.dangerZone.style.display = 'block';
        
        // Show which folders will be deleted
        const flaggedFolderDetails = analysisData.folders
          .filter(folder => analysisData.flaggedFolders.has(folder.name))
          .map(folder => {
            const reasons = folder.flaggedReasons ? ` (${folder.flaggedReasons.join(', ')})` : '';
            return `${folder.path}${reasons}`;
          });
          
        elements.deletionPreview.innerHTML = flaggedFolderDetails.length > 0 
          ? flaggedFolderDetails.join('<br>')
          : 'No flagged folders';
        
        updateDeleteButtonState();
      } else {
        elements.dangerZone.style.display = 'none';
      }
    }

    // Update delete button state
    function updateDeleteButtonState() {
      const canDelete = elements.confirmDelete.checked && 
                       elements.confirmBackup.checked && 
                       elements.confirmUnderstood.checked &&
                       analysisData.flaggedFolders.size > 0;
      elements.deleteFlagged.disabled = !canDelete;
    }

    // Checkbox event listeners
    elements.confirmDelete.addEventListener('change', updateDeleteButtonState);
    elements.confirmBackup.addEventListener('change', updateDeleteButtonState);
    elements.confirmUnderstood.addEventListener('change', updateDeleteButtonState);

    // Re-analyze with new threshold
    function reanalyzeWithNewThreshold() {
      if (analysisData.selectedFolder && analysisData.selectedFolder.images) {
        const threshold = parseInt(elements.brightnessThreshold.value);
        
        analysisData.selectedFolder.images.forEach(image => {
          image.isDark = image.brightness < threshold;
        });
        
        const darkCount = analysisData.selectedFolder.images.filter(img => img.isDark).length;
        analysisData.selectedFolder.darkImageCount = darkCount;
        
        if (darkCount > 0) {
          analysisData.flaggedFolders.add(analysisData.selectedFolder.name);
        } else {
          analysisData.flaggedFolders.delete(analysisData.selectedFolder.name);
        }
        
        renderImagePreview(analysisData.selectedFolder.images);
        displayFolders();
        updateSummaryStats();
        updateDangerZone();
      }
    }

    // Export report
    elements.exportReport.addEventListener('click', () => {
      const report = {
        timestamp: new Date().toISOString(),
        settings: {
          brightnessThreshold: elements.brightnessThreshold.value,
          detectionMethod: elements.detectionMethod.value
        },
        summary: {
          totalFolders: analysisData.folders.length,
          flaggedFolders: analysisData.flaggedFolders.size,
          totalDarkImages: analysisData.folders.reduce((sum, folder) => sum + (folder.darkImageCount || 0), 0)
        },
        folders: analysisData.folders.map(folder => ({
          name: folder.name,
          path: folder.path,
          imageCount: folder.imageCount,
          darkImageCount: folder.darkImageCount || 0,
          avgBrightness: folder.avgBrightness || 0,
          flagged: analysisData.flaggedFolders.has(folder.name)
        }))
      };
      
      const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `dark-image-analysis-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      updateStatus('Report exported successfully');
    });

    // Delete flagged folders (REAL DELETION)
    elements.deleteFlagged.addEventListener('click', async () => {
      if (!elements.confirmDelete.checked || !elements.confirmBackup.checked || !elements.confirmUnderstood.checked) {
        alert('Please check all confirmation boxes before proceeding with deletion.');
        return;
      }
      
      const flaggedFolders = analysisData.folders.filter(folder => analysisData.flaggedFolders.has(folder.name));
      const sessionPaths = flaggedFolders.map(folder => folder.path);
      
      // Final confirmation dialog
      const finalConfirm = confirm(
        `‚ö†Ô∏è FINAL WARNING ‚ö†Ô∏è\n\n` +
        `You are about to PERMANENTLY DELETE ${sessionPaths.length} session folders:\n\n` +
        sessionPaths.map(path => path.split('/').pop()).join('\n') +
        `\n\nThese folders and ALL their contents will be permanently removed from your hard drive.\n\n` +
        `This action CANNOT BE UNDONE!\n\n` +
        `Are you absolutely sure you want to proceed?`
      );
      
      if (!finalConfirm) {
        updateStatus('Deletion cancelled by user');
        return;
      }
      
      try {
        updateStatus(`Deleting ${sessionPaths.length} flagged folders...`);
        updateProgress(10);
        
        const response = await fetch(`${API_BASE}/delete-sessions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionPaths: sessionPaths,
            confirmBackup: true,
            confirmDelete: true
          })
        });
        
        const result = await response.json();
        
        if (!response.ok) throw new Error(result.error || 'Deletion failed');
        
        updateProgress(80);
        
        // Update local data - remove deleted folders
        const deletedPaths = result.results.filter(r => r.deleted).map(r => r.sessionPath);
        analysisData.folders = analysisData.folders.filter(folder => !deletedPaths.includes(folder.path));
        analysisData.flaggedFolders.clear();
        
        updateProgress(100);
        
        const successCount = result.results.filter(r => r.deleted).length;
        const errorCount = result.results.filter(r => !r.deleted).length;
        
        if (errorCount > 0) {
          updateStatus(`Partial success: ${successCount} deleted, ${errorCount} failed. Check console for details.`);
          console.error('Deletion errors:', result.results.filter(r => !r.deleted));
        } else {
          updateStatus(`Successfully deleted ${successCount} session folders`);
        }
        
        // Reset all confirmations
        elements.confirmDelete.checked = false;
        elements.confirmBackup.checked = false;
        elements.confirmUnderstood.checked = false;
        
        // Refresh display
        displayFolders();
        updateSummaryStats();
        updateDangerZone();
        elements.imagePreview.innerHTML = '<p style="text-align: center; color: #666; grid-column: 1 / -1;">Select a folder to preview its images</p>';
        
        setTimeout(() => updateProgress(0), 2000);
        
      } catch (error) {
        updateStatus(`Error during deletion: ${error.message}`);
        updateProgress(0);
        console.error('Deletion error:', error);
      }
    });

    // Initialize
    updateStatus('Ready to analyze folders');
    elements.exportReport.disabled = true;
    
    // Load hangars on page load
    window.addEventListener('load', loadHangars);
  </script>
</body>
</html>